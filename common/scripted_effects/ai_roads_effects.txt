ai_build_roads_with_custom_pathing = {
    if = {
        limit = {
            is_ai = yes
            has_land = yes
            war = no
            any_country_state = {
                count > 1
            }
            ai_country_allowed_to_build_roads = yes
            ai_country_can_afford_to_build_10_roads = yes
        }
        save_scope_as = road_building_country
        set_local_variable = {
            name = ai_country_build_roads_price_cached
            value = ai_country_build_roads_price
        }

        # Used in state_priority_for_road_building to check distance from junction to country capital
        capital_scope = {
            save_scope_as = target_province
        }

        ai_determine_interland_depth_level = yes

        set_local_variable = {
            name = found_any_frontier_states
            value = 1
        }

        while = {
            limit = {
                local_var:found_any_frontier_states > 0
                ai_country_can_afford_to_build_10_roads = yes
            }

            set_local_variable = {
                name = found_any_frontier_states
                value = 0
            }

            ordered_country_state = {
                limit = {
                    capital_scope = {
                        has_variable = interland_depth_level
                    }
                    state_was_tried_for_road_building = no
                    state_junction_has_any_roads = no
                    save_temporary_scope_as = current_frontier_state
                    NOT = {
                        area = {
                            any_neighbor_area = {
                                any_area_state = {
                                    owned_by_road_builder_or_permasubject = yes
                                    state_is_neighbor_of = {
                                        state = scope:current_frontier_state
                                    }

                                    OR = {
                                        state_was_tried_for_road_building = yes
                                        state_junction_has_any_roads = yes
                                    }
                                }
                            }
                        }
                    }
                }
                # Deterministic based on area junction distance from country capital and its territory ID
                order_by = interland_priority_by_depth_level
                position = 0
                check_range_bounds = no

                ai_connect_with_selected_interlands = yes

                set_local_variable = {
                    name = found_any_frontier_states
                    value = 1
                }
            }
        }

        remove_local_variable = found_any_frontier_states

        ordered_country_state = {
            limit = {
                always = no
                any_state_province = {
                    territory_is_junction_of_its_area = yes
                }
            }
            # Deterministic based on area junction distance from country capital and its territory ID
            order_by = state_priority_for_road_building
            min = 0
            max = 999999
            check_range_bounds = no

            # Recheck after every iteration
            if = {
                limit = {
                    scope:road_building_country = {
                        ai_country_can_afford_to_build_10_roads = yes
                    }
                }

                ai_state_to_junction_connection = {
                    specific = 0
                    state = scope:target_province.state
                    processed = 0
                }
            }
        }

        every_in_local_list = {
            variable = interlands_to_clear_depth_level
            capital_scope = {
                remove_variable = interland_depth_level
            }
        }
        clear_local_variable_list = interlands_to_clear_depth_level

        every_in_local_list = {
            variable = junctions_with_processed_list
            clear_variable_list = already_processed_junctions
        }
        clear_local_variable_list = junctions_with_processed_list

        # Garbage collection
        clear_saved_scope = road_building_country
        remove_local_variable = ai_country_build_roads_price_cached
        clear_saved_scope = target_province
    }
}




ai_determine_interland_depth_level = {
    capital_scope.state = {
        # Initiate interland depth calculations starting from destination junction
        capital_scope = {
            set_variable = {
                name = interland_depth_level
                value = 0
            }
        }
        add_to_local_variable_list = {
            name = interlands_of_current_level
            target = this
        }

        # Save it to list so we don't need to every_owned_province to clear interland_depth_level
        add_to_local_variable_list = {
            name = interlands_to_clear_depth_level
            target = this
        }
    }

    # Track it separately in local variable to use it easily as while limit and to set new variables
    set_local_variable = {
        name = current_interland_depth_level
        value = 0
    }

    # Try all neigbours level by level, forming interland depth map to use in pathfinding algorithm later
    while = {
        limit = {
            has_non_empty_local_variable_list = {
                name = interlands_of_current_level
            }
        }

        ordered_in_local_list = {
            variable = interlands_of_current_level
            # Deterministic based on interland ID
            order_by = state_priority_by_area_territory_ids
            min = 0
            max = 999999
            check_range_bounds = no

            save_scope_as = current_interland

            area = {
                ordered_neighbor_area = {
                    # Deterministic based on interland ID
                    order_by = area_priority_by_territory_ids
                    min = 0
                    max = 999999
                    check_range_bounds = no

                    ordered_area_state = {
                        limit = {
                            NOT = {
                                capital_scope = {
                                    has_variable = interland_depth_level
                                }
                            }
                            
                            owned_by_road_builder_or_permasubject = yes

                            state_is_neighbor_of = {
                                state = scope:current_interland
                            }
                        }
                        # Deterministic based on interland ID
                        order_by = area.area_priority_by_territory_ids
                        min = 0
                        max = 999999
                        check_range_bounds = no
                        
                        # Set corresponding depth level as interland variable
                        capital_scope = {
                            set_variable = {
                                name = interland_depth_level
                                value = {
                                    value = local_var:current_interland_depth_level
                                    add = 1
                                }
                            }
                        }
                        # Add to list of the interlands whose neighbours will be processed in the next iteration
                        add_to_local_variable_list = {
                            name = interlands_of_next_level
                            target = this
                        }
                        # Save it to list so we don't need to every_owned_province to clear interland_depth_level
                        add_to_local_variable_list = {
                            name = interlands_to_clear_depth_level
                            target = this
                        }
                    }
                }
            }

            clear_saved_scope = current_interland
        }

        # Set next level interlands as current level for the next iteration 
        clear_local_variable_list = interlands_of_current_level
        every_in_local_list = {
            variable = interlands_of_next_level
            add_to_local_variable_list = {
                name = interlands_of_current_level
                target = this
            }
        }
        clear_local_variable_list = interlands_of_next_level

        # Increment local variable with current interland depth level
        change_local_variable = {
            name = current_interland_depth_level
            add = 1
        }
    }

    # Garbage collection
    clear_local_variable_list = interlands_of_current_level
    remove_local_variable = current_interland_depth_level
}







ai_determine_junctions_to_connect = {
    if = {
        limit = {
            $specific$ = 1
        }
        $state$ = {
            ai_determine_junctions_to_connect_1 = {
                processed = $processed$
            }
        }
    }
    else = {
        area = {
            ordered_neighbor_area = {
                limit = {
                    any_area_state = {
                        # Must be owned either by the country itself or its subject with subject_can_cancel = no
                        owned_by_road_builder_or_permasubject = yes
                        # Is adjacent to current state by land path
                        state_is_neighbor_of = {
                            state = scope:current_state_junction.state
                        }
                        # Junction is located in this state
                        any_state_province = {
                            territory_is_junction_of_its_area = yes
                        }
                    }
                }

                # Deterministic based on sum of area territory IDs
                order_by = interland_area_priority_by_depth_level
                min = 0
                max = 999999
                check_range_bounds = no

                random_area_state = {
                    limit = {
                        owned_by_road_builder_or_permasubject = yes
                    }
                    ai_determine_junctions_to_connect_1 = {
                        processed = $processed$
                    }
                }
            }
        }
    }
}

ai_determine_junctions_to_connect_1 = {
    ordered_state_province = {
        limit = {
            territory_is_junction_of_its_area = yes
        }
        # There shouldn't ever be more than one junction per area, but for safety it's deterministic by ID
        order_by = territory_priority_by_id
        position = 0
        check_range_bounds = no

        # Regardless of everything else, territory determined to be junction stays it for a lifetime
        if = {
            limit = {
                NOT = {
                    has_variable = area_junction_territory
                }
            }
            set_variable = area_junction_territory
        }

        # Try connecting with this junction only if this pair wasn't processed before
        if = {
            limit = {
                OR = {
                    $processed$ = 1
                    NOR = {
                        AND = {
                            has_non_empty_variable_list = {
                                name = already_processed_junctions
                            }
                            is_target_in_variable_list = {
                                name = already_processed_junctions
                                target = scope:current_state_junction
                            }
                        }
                        scope:current_state_junction = {
                            has_non_empty_variable_list = {
                                name = already_processed_junctions
                            }
                            is_target_in_variable_list = {
                                name = already_processed_junctions
                                target = prev
                            }
                        }
                    }
                }
            }
            add_to_local_variable_list = {
                name = neighbor_junctions_to_connect
                target = this
            }
        }
    }
}

ai_determine_territory_depth_level = {
    # Initiate territory depth calculations starting from destination junction
    set_variable = {
        name = territory_depth_level
        value = 0
    }
    add_to_local_variable_list = {
        name = territories_of_current_level
        target = this
    }

    # Save it to list so we don't need to every_owned_province to clear territory_depth_level
    add_to_local_variable_list = {
        name = territories_to_clear_depth_level
        target = this
    }

    # Track it separately in local variable to use it easily as while limit and to set new variables
    set_local_variable = {
        name = current_territory_depth_level
        value = 0
    }

    # Try all neigbours level by level, forming territory depth map to use in pathfinding algorithm later
    while = {
        limit = {
            local_var:current_territory_depth_level < road_building_junction_search_depth
            # If all the junctions were already found, there's no need to go deeper, so save performance
            any_in_local_list = {
                variable = neighbor_junctions_to_connect
                NOT = {
                    has_variable = territory_depth_level
                }
            }
        }

        ordered_in_local_list = {
            variable = territories_of_current_level
            # Deterministic based on territory ID
            order_by = territory_priority_by_id
            min = 0
            max = 999999
            check_range_bounds = no

            ordered_neighbor_province = {
                limit = {
                    # Only land territories that armies can walk on
                    is_water = no
                    NOT = {
                        terrain = impassable_terrain
                    }
                    # Not processed previously
                    NOT = {
                        has_variable = territory_depth_level
                    }
                    OR = {
                        # Uncolonized and uninhabitable territories
                        NOT = {
                            exists = owner
                        }
                        # Must be owned either by the country itself or its subject with subject_can_cancel = no
                        owned_by_road_builder_or_permasubject = yes
                    }
                }
                # Deterministic based on territory ID
                order_by = territory_priority_by_id
                min = 0
                max = 999999
                check_range_bounds = no
                
                # Set corresponding depth level as territory variable
                set_variable = {
                    name = territory_depth_level
                    value = {
                        value = local_var:current_territory_depth_level
                        add = 1
                    }
                }
                # Add to list of the territories whose neighbours will be processed in the next iteration
                add_to_local_variable_list = {
                    name = territories_of_next_level
                    target = this
                }
                # Save it to list so we don't need to every_owned_province to clear territory_depth_level
                add_to_local_variable_list = {
                    name = territories_to_clear_depth_level
                    target = this
                }
            }
        }

        # Set next level territories as current level for the next iteration 
        clear_local_variable_list = territories_of_current_level
        every_in_local_list = {
            variable = territories_of_next_level
            add_to_local_variable_list = {
                name = territories_of_current_level
                target = this
            }
        }
        clear_local_variable_list = territories_of_next_level

        # Increment local variable with current territory depth level
        change_local_variable = {
            name = current_territory_depth_level
            add = 1
        }
    }

    # Garbage collection
    clear_local_variable_list = territories_of_current_level
    remove_local_variable = current_territory_depth_level
}


ai_connect_with_selected_interlands = {
    # Start with the destination junction and find a path to current state junction
    save_scope_as = current_road_interland

    # Save all processed interlands to a list so we wont't walk them more than once
    add_to_local_variable_list = {
        name = already_processed_interlands
        target = this
    }

    # Emergency exist for edge cases to prevent while loop from going on 1000 times
    set_local_variable = {
        name = found_new_interland_for_road
        value = 1
    }

    while = {
        limit = {
            local_var:found_new_interland_for_road > 0
            scope:current_road_interland = {
                interland_depth_level_svalue > 0
            }
            scope:road_building_country = {
                ai_country_can_afford_to_build_10_roads = yes
            }
        }

        # Reset it to 0 on every iteration, update to 1 after finding new interland
        set_local_variable = {
            name = found_new_interland_for_road
            value = 0
        }

        scope:current_road_interland.area = {
            ordered_neighbor_area = {
                limit = {
                    area_is_eligible_for_interland_connect = yes
                }
                
                # Deterministic preference based on existing roads, being a city, etc.
                order_by = area_priority_for_road_building
                position = 0
                check_range_bounds = no

                random_area_state = {
                    limit = {
                        interland_eligible_for_road_building = yes
                    }
                    
                    # Save current interland as previous to track pairs, then set this one as current
                    scope:current_road_interland = {
                        save_scope_as = previous_road_interland
                    }
                    save_scope_as = current_road_interland
                    
                    scope:previous_road_interland = {
                        ai_state_to_junction_connection = {
                            specific = 1
                            state = scope:current_road_interland
                            processed = 1
                        }
                    }

                    # Mark that we were able to find some new interland and while loop can continue
                    set_local_variable = {
                        name = found_new_interland_for_road
                        value = 1
                    }

                    # Save all processed interlands to a list so we wont't walk them more than once
                    add_to_local_variable_list = {
                        name = already_processed_interlands
                        target = this
                    }
                }
            }
        }
    }

    # Garbage collection
    clear_saved_scope = current_road_interland
    clear_saved_scope = previous_road_interland
    clear_local_variable_list = already_processed_interlands
    remove_local_variable = found_new_interland_for_road
}

ai_state_to_junction_connection = {
    ordered_state_province = {
        limit = {
            territory_is_junction_of_its_area = yes
        }
        # There shouldn't ever be more than one junction per area, but for safety it's deterministic by ID
        order_by = province_id
        position = 0
        check_range_bounds = no

        # Regardless of everything else, territory determined to be junction stays it for a lifetime
        if = {
            limit = {
                NOT = {
                    has_variable = area_junction_territory
                }
            }
            set_variable = area_junction_territory
        }

        save_scope_as = current_state_junction

        ai_determine_junctions_to_connect = {
            specific = $specific$
            state = $state$
            processed = $processed$
        }
        ai_determine_territory_depth_level = yes
        ai_connect_with_selected_junctions = yes

        clear_local_variable_list = neighbor_junctions_to_connect

        every_in_local_list = {
            variable = territories_to_clear_depth_level
            remove_variable = territory_depth_level
        }
        clear_local_variable_list = territories_to_clear_depth_level

        clear_saved_scope = current_state_junction
    }
}

ai_connect_with_selected_junctions = {
    ordered_in_local_list = {
        variable = neighbor_junctions_to_connect
        limit = {
            has_variable = territory_depth_level
        }
        # Deterministic based on distance from capital
        order_by = territory_priority_by_distance_from_capital
        position = 0
        check_range_bounds = no

        # Start with the destination junction and find a path to current state junction
        save_scope_as = current_road_territory

        # Save all processed territories to a list so we wont't walk them more than once
        add_to_local_variable_list = {
            name = already_processed_territories
            target = this
        }

        # Emergency exist for edge cases to prevent while loop from going on 1000 times
        set_local_variable = {
            name = found_new_territory_for_road
            value = 1
        }

        while = {
            limit = {
                local_var:found_new_territory_for_road > 0
                scope:current_road_territory = {
                    territory_depth_level_svalue > 0
                }
                scope:road_building_country = {
                    ai_country_can_afford_to_build_1_road = yes
                }
            }

            # Reset it to 0 on every iteration, update to 1 after finding new territory
            set_local_variable = {
                name = found_new_territory_for_road
                value = 0
            }

            scope:current_road_territory = {
                ordered_neighbor_province = {
                    limit = {
                        province_is_eligible_for_road_building = yes
                    }
                    # Deterministic preference based on existing roads, being a city, etc.
                    order_by = territory_priority_for_road_building
                    position = 0
                    check_range_bounds = no

                    if = {
                        limit = {
                            NOT = {
                                has_road_towards = scope:current_road_territory
                            }
                        }
                        add_to_variable_list = {
                            name = will_have_road_towards
                            target = scope:current_road_territory
                        }
                    }
                    
                    # Save current territory as previous to track pairs, then set this one as current
                    scope:current_road_territory = {
                        save_scope_as = previous_road_territory
                    }
                    save_scope_as = current_road_territory

                    # Mark that we were able to find some new territory and while loop can continue
                    set_local_variable = {
                        name = found_new_territory_for_road
                        value = 1
                    }

                    # Save all processed territories to a list so we wont't walk them more than once
                    add_to_local_variable_list = {
                        name = already_processed_territories
                        target = this
                    }
                }
            }
        }

        if = {
            limit = {
                trigger_if = {
                    limit = {
                        is_advanced_ai_enabled = yes
                        NOT = {
                            has_global_variable = game_rule_advanced_ai_mercenaries
                        }
                    }
                    treasury >= ai_wartime_fund_and_planned_roads
                }
                trigger_else = {
                    treasury >= cumulated_cost_of_planned_roads
                }
            }
            every_in_local_list = {
                variable = already_processed_territories
                limit = {
                    has_non_empty_variable_list = will_have_road_towards
                }
                save_scope_as = territory_to_build_road_from
                every_in_list = {
                    variable = will_have_road_towards
                    scope:territory_to_build_road_from = {
                        add_road_towards = prev
                    }
                    scope:road_building_country = {
                        add_treasury = {
                            value = 0
                            subtract = ai_country_build_roads_price
                        }
                    }
                }
                clear_saved_scope = territory_to_build_road_from
            }
        }
        
        every_in_local_list = {
            variable = already_processed_territories
            limit = {
                has_non_empty_variable_list = will_have_road_towards
            }
            clear_variable_list = will_have_road_towards
        }
        
        # Mark that we already (or rather will very soon) processed this pair of junctions
        add_to_variable_list = {
            name = already_processed_junctions
            target = scope:current_state_junction
        }
        scope:current_state_junction = {
            add_to_variable_list = {
                name = already_processed_junctions
                target = prev
            }
        }
        # Save it to list so we don't need to every_owned_province to clear already_processed_junctions
        add_to_local_variable_list = {
            name = junctions_with_processed_list
            target = this
        }
        add_to_local_variable_list = {
            name = junctions_with_processed_list
            target = scope:current_state_junction
        }

        # Garbage collection
        clear_saved_scope = current_road_territory
        clear_saved_scope = previous_road_territory
        clear_local_variable_list = already_processed_territories
        remove_local_variable = found_new_territory_for_road
    }
}